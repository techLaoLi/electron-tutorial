## 07 文件系统与原生能力

- 目标：通过主进程封装受控的原生能力，并在渲染端以安全 API 使用。

### 文件系统基础概念

#### Node.js fs 模块

Electron 基于 Node.js，可以使用完整的文件系统 API：

```js
import { promises as fs } from "node:fs";
import fs from "node:fs"; // 同步版本
import path from "node:path";
```

#### 路径处理

- 使用 `path` 模块处理跨平台路径
- 常用方法：`join()`, `resolve()`, `dirname()`, `basename()`, `extname()`
- 避免硬编码路径分隔符

```js
import path from "node:path";

// 正确的路径处理
const userDataPath = path.join(app.getPath("userData"), "config.json");
const relativePath = path.resolve("./assets", "icon.png");
```

#### 文件操作类型

1. **同步操作**：阻塞主线程，简单但性能差
2. **异步回调**：传统 Node.js 风格
3. **Promise 版本**：推荐使用，支持 async/await

```js
// 推荐：Promise 版本
const content = await fs.readFile("file.txt", "utf8");
await fs.writeFile("output.txt", content);

// 避免：同步版本（阻塞）
const content = fs.readFileSync("file.txt", "utf8");
```

### 文件系统封装

#### 基础文件操作

```ts
import { ipcMain, dialog } from "electron";
import { promises as fs } from "node:fs";
import path from "node:path";

// 文件对话框
ipcMain.handle("dialog:open-file", async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({
    properties: ["openFile"],
  });
  if (canceled || filePaths.length === 0) return null;
  return filePaths[0];
});

ipcMain.handle("dialog:save-file", async () => {
  const { canceled, filePath } = await dialog.showSaveDialog({
    defaultPath: "untitled.txt",
  });
  return canceled ? null : filePath;
});

// 文本文件操作
ipcMain.handle("fs:read-text", async (_e, filePath: string) => {
  try {
    const content = await fs.readFile(filePath, "utf8");
    return { success: true, content };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle(
  "fs:write-text",
  async (_e, filePath: string, content: string) => {
    try {
      await fs.writeFile(filePath, content, "utf8");
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
);

// 二进制文件操作
ipcMain.handle("fs:read-binary", async (_e, filePath: string) => {
  try {
    const buffer = await fs.readFile(filePath);
    return { success: true, data: buffer.toString("base64") };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle(
  "fs:write-binary",
  async (_e, filePath: string, base64Data: string) => {
    try {
      const buffer = Buffer.from(base64Data, "base64");
      await fs.writeFile(filePath, buffer);
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
);
```

#### 目录操作

```ts
// 目录操作
ipcMain.handle("fs:readdir", async (_e, dirPath: string) => {
  try {
    const items = await fs.readdir(dirPath, { withFileTypes: true });
    return {
      success: true,
      items: items.map((item) => ({
        name: item.name,
        isDirectory: item.isDirectory(),
        isFile: item.isFile(),
      })),
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle("fs:mkdir", async (_e, dirPath: string, recursive = true) => {
  try {
    await fs.mkdir(dirPath, { recursive });
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle("fs:rmdir", async (_e, dirPath: string, recursive = false) => {
  try {
    await fs.rmdir(dirPath, { recursive });
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});
```

#### 文件信息与监控

```ts
// 文件信息
ipcMain.handle("fs:stat", async (_e, filePath: string) => {
  try {
    const stats = await fs.stat(filePath);
    return {
      success: true,
      stats: {
        size: stats.size,
        mtime: stats.mtime.toISOString(),
        ctime: stats.ctime.toISOString(),
        isFile: stats.isFile(),
        isDirectory: stats.isDirectory(),
      },
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// 文件监控（需要导入 fs.watch）
import { watch } from "node:fs";

const watchers = new Map();

ipcMain.handle("fs:watch", async (_e, filePath: string) => {
  try {
    const watcher = watch(filePath, (eventType, filename) => {
      // 发送文件变化事件到渲染进程
      mainWindow?.webContents.send("file-changed", { eventType, filename });
    });
    watchers.set(filePath, watcher);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle("fs:unwatch", async (_e, filePath: string) => {
  const watcher = watchers.get(filePath);
  if (watcher) {
    watcher.close();
    watchers.delete(filePath);
    return { success: true };
  }
  return { success: false, error: "Watcher not found" };
});
```

### 文件系统使用场景

#### 1. 应用配置管理

```ts
// 配置文件管理
ipcMain.handle("config:load", async () => {
  const configPath = path.join(app.getPath("userData"), "config.json");
  try {
    const data = await fs.readFile(configPath, "utf8");
    return { success: true, config: JSON.parse(data) };
  } catch (error) {
    // 配置文件不存在时返回默认配置
    return { success: true, config: { theme: "light", language: "zh-CN" } };
  }
});

ipcMain.handle("config:save", async (_e, config: any) => {
  const configPath = path.join(app.getPath("userData"), "config.json");
  try {
    await fs.writeFile(configPath, JSON.stringify(config, null, 2));
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});
```

#### 2. 数据持久化存储

```ts
// 本地数据库文件
ipcMain.handle("data:save", async (_e, table: string, data: any[]) => {
  const dataPath = path.join(app.getPath("userData"), "data", `${table}.json`);
  try {
    // 确保目录存在
    await fs.mkdir(path.dirname(dataPath), { recursive: true });
    await fs.writeFile(dataPath, JSON.stringify(data, null, 2));
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle("data:load", async (_e, table: string) => {
  const dataPath = path.join(app.getPath("userData"), "data", `${table}.json`);
  try {
    const data = await fs.readFile(dataPath, "utf8");
    return { success: true, data: JSON.parse(data) };
  } catch (error) {
    return { success: false, error: error.message };
  }
});
```

#### 3. 日志记录系统

```ts
// 日志记录
ipcMain.handle("log:write", async (_e, level: string, message: string) => {
  const logDir = path.join(app.getPath("userData"), "logs");
  const logFile = path.join(
    logDir,
    `${new Date().toISOString().split("T")[0]}.log`
  );

  try {
    await fs.mkdir(logDir, { recursive: true });
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${level.toUpperCase()}: ${message}\n`;
    await fs.appendFile(logFile, logEntry);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});
```

#### 4. 文件导入导出功能

```ts
// 数据导出
ipcMain.handle(
  "export:data",
  async (_e, data: any, format: "json" | "csv" = "json") => {
    const { canceled, filePath } = await dialog.showSaveDialog({
      defaultPath: `export_${new Date().toISOString().split("T")[0]}.${format}`,
      filters: [
        { name: "JSON Files", extensions: ["json"] },
        { name: "CSV Files", extensions: ["csv"] },
      ],
    });

    if (canceled) return { success: false, error: "Export canceled" };

    try {
      let content: string;
      if (format === "json") {
        content = JSON.stringify(data, null, 2);
      } else {
        // CSV 转换逻辑
        content = convertToCSV(data);
      }

      await fs.writeFile(filePath, content, "utf8");
      return { success: true, filePath };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
);

// 数据导入
ipcMain.handle("import:data", async () => {
  const { canceled, filePaths } = await dialog.showOpenDialog({
    properties: ["openFile"],
    filters: [
      { name: "JSON Files", extensions: ["json"] },
      { name: "CSV Files", extensions: ["csv"] },
    ],
  });

  if (canceled || filePaths.length === 0)
    return { success: false, error: "Import canceled" };

  try {
    const content = await fs.readFile(filePaths[0], "utf8");
    const ext = path.extname(filePaths[0]).toLowerCase();

    let data: any;
    if (ext === ".json") {
      data = JSON.parse(content);
    } else if (ext === ".csv") {
      data = parseCSV(content);
    }

    return { success: true, data };
  } catch (error) {
    return { success: false, error: error.message };
  }
});
```

#### 5. 文件管理器功能

```ts
// 文件浏览器
ipcMain.handle("file:explore", async (_e, dirPath?: string) => {
  const targetPath = dirPath || app.getPath("documents");

  try {
    const items = await fs.readdir(targetPath, { withFileTypes: true });
    const files = [];
    const directories = [];

    for (const item of items) {
      const fullPath = path.join(targetPath, item.name);
      const stats = await fs.stat(fullPath);

      const fileInfo = {
        name: item.name,
        path: fullPath,
        size: stats.size,
        mtime: stats.mtime,
        isDirectory: item.isDirectory(),
        isFile: item.isFile(),
      };

      if (item.isDirectory()) {
        directories.push(fileInfo);
      } else {
        files.push(fileInfo);
      }
    }

    return {
      success: true,
      currentPath: targetPath,
      directories: directories.sort((a, b) => a.name.localeCompare(b.name)),
      files: files.sort((a, b) => a.name.localeCompare(b.name)),
    };
  } catch (error) {
    return { success: false, error: error.message };
  }
});
```

#### 6. 媒体文件处理

```ts
// 图片处理
ipcMain.handle(
  "image:process",
  async (_e, imagePath: string, operations: any[]) => {
    try {
      // 这里可以集成 sharp 等图像处理库
      const { default: sharp } = await import("sharp");

      let pipeline = sharp(imagePath);

      for (const op of operations) {
        switch (op.type) {
          case "resize":
            pipeline = pipeline.resize(op.width, op.height);
            break;
          case "rotate":
            pipeline = pipeline.rotate(op.angle);
            break;
          case "format":
            pipeline = pipeline.toFormat(op.format);
            break;
        }
      }

      const outputPath = path.join(
        path.dirname(imagePath),
        `processed_${path.basename(imagePath)}`
      );
      await pipeline.toFile(outputPath);

      return { success: true, outputPath };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
);
```

#### 7. 备份与同步

```ts
// 数据备份
ipcMain.handle("backup:create", async (_e, backupName?: string) => {
  const backupDir = path.join(app.getPath("documents"), "AppBackups");
  const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
  const backupName = backupName || `backup_${timestamp}`;
  const backupPath = path.join(backupDir, backupName);

  try {
    await fs.mkdir(backupPath, { recursive: true });

    // 复制用户数据
    const userDataPath = app.getPath("userData");
    await copyDirectory(userDataPath, backupPath);

    return { success: true, backupPath };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// 辅助函数：复制目录
async function copyDirectory(src: string, dest: string) {
  await fs.mkdir(dest, { recursive: true });
  const items = await fs.readdir(src, { withFileTypes: true });

  for (const item of items) {
    const srcPath = path.join(src, item.name);
    const destPath = path.join(dest, item.name);

    if (item.isDirectory()) {
      await copyDirectory(srcPath, destPath);
    } else {
      await fs.copyFile(srcPath, destPath);
    }
  }
}
```

### 错误处理与安全考虑

#### 路径安全

```ts
// 路径验证
function validatePath(filePath: string, basePath?: string) {
  const base = basePath || app.getPath("userData");
  const resolvedPath = path.resolve(base, filePath);

  // 确保路径在允许的目录内
  if (!resolvedPath.startsWith(base)) {
    throw new Error("Path traversal attack detected");
  }

  return resolvedPath;
}

ipcMain.handle("fs:safe-read", async (_e, filePath: string) => {
  try {
    const safePath = validatePath(filePath);
    const content = await fs.readFile(safePath, "utf8");
    return { success: true, content };
  } catch (error) {
    return { success: false, error: error.message };
  }
});
```

#### 文件大小限制

```ts
// 文件大小检查
const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

ipcMain.handle("fs:read-with-limit", async (_e, filePath: string) => {
  try {
    const stats = await fs.stat(filePath);
    if (stats.size > MAX_FILE_SIZE) {
      return { success: false, error: "File too large" };
    }

    const content = await fs.readFile(filePath, "utf8");
    return { success: true, content };
  } catch (error) {
    return { success: false, error: error.message };
  }
});
```

### 剪贴板、通知等

```ts
import { clipboard, Notification } from "electron";

ipcMain.handle("clipboard:readText", () => clipboard.readText());
ipcMain.handle("clipboard:writeText", (_e, text: string) => {
  clipboard.writeText(text);
  return true;
});
ipcMain.handle("clipboard:readImage", () => {
  const image = clipboard.readImage();
  return image.isEmpty() ? null : image.toDataURL();
});

ipcMain.handle("notify:show", (_e, title: string, body: string) => {
  new Notification({ title, body }).show();
});

// 系统信息
ipcMain.handle("system:info", () => ({
  platform: process.platform,
  arch: process.arch,
  version: process.version,
  electronVersion: process.versions.electron,
  chromeVersion: process.versions.chrome,
}));
```

### 实际代码示例

#### 完整的文件系统服务类

```ts
// file-system-service.ts
import { ipcMain, dialog, app } from "electron";
import { promises as fs, watch } from "node:fs";
import path from "node:path";

export class FileSystemService {
  private watchers = new Map<string, any>();
  private readonly MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB

  constructor() {
    this.registerHandlers();
  }

  private registerHandlers() {
    // 文件对话框
    ipcMain.handle("fs:open-file", this.openFileDialog.bind(this));
    ipcMain.handle("fs:save-file", this.saveFileDialog.bind(this));

    // 文件操作
    ipcMain.handle("fs:read-text", this.readTextFile.bind(this));
    ipcMain.handle("fs:write-text", this.writeTextFile.bind(this));
    ipcMain.handle("fs:read-binary", this.readBinaryFile.bind(this));
    ipcMain.handle("fs:write-binary", this.writeBinaryFile.bind(this));

    // 目录操作
    ipcMain.handle("fs:list-dir", this.listDirectory.bind(this));
    ipcMain.handle("fs:create-dir", this.createDirectory.bind(this));
    ipcMain.handle("fs:delete-file", this.deleteFile.bind(this));

    // 文件信息
    ipcMain.handle("fs:get-stats", this.getFileStats.bind(this));

    // 文件监控
    ipcMain.handle("fs:watch-file", this.watchFile.bind(this));
    ipcMain.handle("fs:unwatch-file", this.unwatchFile.bind(this));
  }

  private async openFileDialog() {
    const { canceled, filePaths } = await dialog.showOpenDialog({
      properties: ["openFile"],
      filters: [
        { name: "All Files", extensions: ["*"] },
        { name: "Text Files", extensions: ["txt", "md", "json"] },
        { name: "Images", extensions: ["jpg", "png", "gif"] },
      ],
    });
    return canceled ? null : filePaths[0];
  }

  private async saveFileDialog() {
    const { canceled, filePath } = await dialog.showSaveDialog({
      defaultPath: "untitled.txt",
      filters: [
        { name: "Text Files", extensions: ["txt"] },
        { name: "JSON Files", extensions: ["json"] },
      ],
    });
    return canceled ? null : filePath;
  }

  private async readTextFile(_e: any, filePath: string) {
    try {
      this.validatePath(filePath);
      const stats = await fs.stat(filePath);

      if (stats.size > this.MAX_FILE_SIZE) {
        throw new Error("File too large");
      }

      const content = await fs.readFile(filePath, "utf8");
      return { success: true, content };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private async writeTextFile(_e: any, filePath: string, content: string) {
    try {
      this.validatePath(filePath);

      // 确保目录存在
      const dir = path.dirname(filePath);
      await fs.mkdir(dir, { recursive: true });

      await fs.writeFile(filePath, content, "utf8");
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private async readBinaryFile(_e: any, filePath: string) {
    try {
      this.validatePath(filePath);
      const stats = await fs.stat(filePath);

      if (stats.size > this.MAX_FILE_SIZE) {
        throw new Error("File too large");
      }

      const buffer = await fs.readFile(filePath);
      return { success: true, data: buffer.toString("base64") };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private async writeBinaryFile(_e: any, filePath: string, base64Data: string) {
    try {
      this.validatePath(filePath);

      const dir = path.dirname(filePath);
      await fs.mkdir(dir, { recursive: true });

      const buffer = Buffer.from(base64Data, "base64");
      await fs.writeFile(filePath, buffer);
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private async listDirectory(_e: any, dirPath: string) {
    try {
      this.validatePath(dirPath);
      const items = await fs.readdir(dirPath, { withFileTypes: true });

      const result = [];
      for (const item of items) {
        const fullPath = path.join(dirPath, item.name);
        const stats = await fs.stat(fullPath);

        result.push({
          name: item.name,
          path: fullPath,
          isDirectory: item.isDirectory(),
          isFile: item.isFile(),
          size: stats.size,
          mtime: stats.mtime,
          ctime: stats.ctime,
        });
      }

      return { success: true, items: result };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private async createDirectory(_e: any, dirPath: string) {
    try {
      this.validatePath(dirPath);
      await fs.mkdir(dirPath, { recursive: true });
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private async deleteFile(_e: any, filePath: string) {
    try {
      this.validatePath(filePath);
      await fs.unlink(filePath);
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private async getFileStats(_e: any, filePath: string) {
    try {
      this.validatePath(filePath);
      const stats = await fs.stat(filePath);

      return {
        success: true,
        stats: {
          size: stats.size,
          mtime: stats.mtime.toISOString(),
          ctime: stats.ctime.toISOString(),
          isFile: stats.isFile(),
          isDirectory: stats.isDirectory(),
          isSymbolicLink: stats.isSymbolicLink(),
        },
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private async watchFile(_e: any, filePath: string) {
    try {
      this.validatePath(filePath);

      if (this.watchers.has(filePath)) {
        return { success: false, error: "File already being watched" };
      }

      const watcher = watch(filePath, (eventType, filename) => {
        // 发送文件变化事件到渲染进程
        const mainWindow = require("./main").getMainWindow();
        mainWindow?.webContents.send("file-changed", {
          filePath,
          eventType,
          filename,
        });
      });

      this.watchers.set(filePath, watcher);
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  private async unwatchFile(_e: any, filePath: string) {
    const watcher = this.watchers.get(filePath);
    if (watcher) {
      watcher.close();
      this.watchers.delete(filePath);
      return { success: true };
    }
    return { success: false, error: "Watcher not found" };
  }

  private validatePath(filePath: string) {
    const userDataPath = app.getPath("userData");
    const documentsPath = app.getPath("documents");
    const downloadsPath = app.getPath("downloads");

    const allowedPaths = [userDataPath, documentsPath, downloadsPath];
    const resolvedPath = path.resolve(filePath);

    const isAllowed = allowedPaths.some((allowedPath) =>
      resolvedPath.startsWith(allowedPath)
    );

    if (!isAllowed) {
      throw new Error("Access denied: Path outside allowed directories");
    }

    // 检查路径遍历攻击
    if (resolvedPath.includes("..")) {
      throw new Error("Path traversal attack detected");
    }
  }

  public cleanup() {
    // 清理所有文件监控器
    for (const [filePath, watcher] of this.watchers) {
      watcher.close();
    }
    this.watchers.clear();
  }
}

// 在主进程中初始化
const fileSystemService = new FileSystemService();

// 应用退出时清理资源
app.on("will-quit", () => {
  fileSystemService.cleanup();
});
```

#### 预加载脚本中的文件系统 API

```ts
// preload.js
const { contextBridge, ipcRenderer } = require("electron");

contextBridge.exposeInMainWorld("fileSystem", {
  // 文件对话框
  openFile: () => ipcRenderer.invoke("fs:open-file"),
  saveFile: () => ipcRenderer.invoke("fs:save-file"),

  // 文件操作
  readText: (filePath) => ipcRenderer.invoke("fs:read-text", filePath),
  writeText: (filePath, content) =>
    ipcRenderer.invoke("fs:write-text", filePath, content),
  readBinary: (filePath) => ipcRenderer.invoke("fs:read-binary", filePath),
  writeBinary: (filePath, data) =>
    ipcRenderer.invoke("fs:write-binary", filePath, data),

  // 目录操作
  listDirectory: (dirPath) => ipcRenderer.invoke("fs:list-dir", dirPath),
  createDirectory: (dirPath) => ipcRenderer.invoke("fs:create-dir", dirPath),
  deleteFile: (filePath) => ipcRenderer.invoke("fs:delete-file", filePath),

  // 文件信息
  getStats: (filePath) => ipcRenderer.invoke("fs:get-stats", filePath),

  // 文件监控
  watchFile: (filePath) => ipcRenderer.invoke("fs:watch-file", filePath),
  unwatchFile: (filePath) => ipcRenderer.invoke("fs:unwatch-file", filePath),

  // 监听文件变化事件
  onFileChanged: (callback) => {
    ipcRenderer.on("file-changed", callback);
  },

  // 移除文件变化监听器
  offFileChanged: (callback) => {
    ipcRenderer.removeListener("file-changed", callback);
  },
});
```

#### 渲染进程中的使用示例

```ts
// renderer.js
class FileManager {
  constructor() {
    this.setupEventListeners();
  }

  setupEventListeners() {
    // 监听文件变化
    window.fileSystem.onFileChanged((event, data) => {
      console.log("File changed:", data);
      this.handleFileChange(data);
    });
  }

  async openFile() {
    try {
      const filePath = await window.fileSystem.openFile();
      if (!filePath) return;

      const result = await window.fileSystem.readText(filePath);
      if (result.success) {
        this.displayFileContent(result.content);
        // 开始监控文件变化
        await window.fileSystem.watchFile(filePath);
      } else {
        this.showError(result.error);
      }
    } catch (error) {
      this.showError("Failed to open file: " + error.message);
    }
  }

  async saveFile(content) {
    try {
      const filePath = await window.fileSystem.saveFile();
      if (!filePath) return;

      const result = await window.fileSystem.writeText(filePath, content);
      if (result.success) {
        this.showSuccess("File saved successfully");
      } else {
        this.showError(result.error);
      }
    } catch (error) {
      this.showError("Failed to save file: " + error.message);
    }
  }

  async browseDirectory(dirPath = null) {
    try {
      const result = await window.fileSystem.listDirectory(dirPath);
      if (result.success) {
        this.displayDirectoryContents(result.items);
      } else {
        this.showError(result.error);
      }
    } catch (error) {
      this.showError("Failed to browse directory: " + error.message);
    }
  }

  handleFileChange(data) {
    // 处理文件变化事件
    if (data.eventType === "change") {
      this.showNotification("File modified: " + data.filename);
      // 可以重新加载文件内容
      this.refreshCurrentFile();
    }
  }

  displayFileContent(content) {
    const editor = document.getElementById("editor");
    if (editor) {
      editor.value = content;
    }
  }

  displayDirectoryContents(items) {
    const container = document.getElementById("file-list");
    if (!container) return;

    container.innerHTML = "";

    items.forEach((item) => {
      const element = document.createElement("div");
      element.className = item.isDirectory ? "directory" : "file";
      element.textContent = item.name;

      if (item.isDirectory) {
        element.onclick = () => this.browseDirectory(item.path);
      } else {
        element.onclick = () => this.openFile(item.path);
      }

      container.appendChild(element);
    });
  }

  showError(message) {
    // 显示错误消息
    console.error(message);
    // 可以集成到 UI 框架中显示错误提示
  }

  showSuccess(message) {
    // 显示成功消息
    console.log(message);
    // 可以集成到 UI 框架中显示成功提示
  }

  showNotification(message) {
    // 显示通知
    console.log(message);
    // 可以集成到 UI 框架中显示通知
  }
}

// 初始化文件管理器
const fileManager = new FileManager();
```

### 最佳实践

#### 1. 错误处理

```ts
// 统一的错误处理
class FileSystemError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = "FileSystemError";
  }
}

// 错误处理包装器
async function handleFileOperation<T>(
  operation: () => Promise<T>,
  errorMessage: string
): Promise<{ success: boolean; data?: T; error?: string }> {
  try {
    const data = await operation();
    return { success: true, data };
  } catch (error) {
    console.error(errorMessage, error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}
```

#### 2. 性能优化

```ts
// 大文件分块读取
async function readLargeFile(filePath: string, chunkSize = 1024 * 1024) {
  const stats = await fs.stat(filePath);
  const chunks = [];

  for (let offset = 0; offset < stats.size; offset += chunkSize) {
    const buffer = Buffer.alloc(Math.min(chunkSize, stats.size - offset));
    const fd = await fs.open(filePath, "r");

    await fd.read(buffer, 0, buffer.length, offset);
    chunks.push(buffer);

    await fd.close();
  }

  return Buffer.concat(chunks);
}

// 文件流处理
import { createReadStream, createWriteStream } from "node:fs";

async function copyLargeFile(src: string, dest: string) {
  return new Promise((resolve, reject) => {
    const readStream = createReadStream(src);
    const writeStream = createWriteStream(dest);

    readStream.pipe(writeStream);

    writeStream.on("finish", resolve);
    writeStream.on("error", reject);
    readStream.on("error", reject);
  });
}
```

#### 3. 安全考虑

```ts
// 文件类型验证
function validateFileType(filePath: string, allowedTypes: string[]) {
  const ext = path.extname(filePath).toLowerCase();
  return allowedTypes.includes(ext);
}

// 文件大小限制
function validateFileSize(filePath: string, maxSize: number) {
  const stats = fs.statSync(filePath);
  return stats.size <= maxSize;
}

// 路径白名单
function isPathAllowed(filePath: string, allowedPaths: string[]) {
  const resolvedPath = path.resolve(filePath);
  return allowedPaths.some((allowedPath) =>
    resolvedPath.startsWith(path.resolve(allowedPath))
  );
}
```

### 本章要点

- 原生能力统一由主进程封装、白名单暴露
- 对话框等 UI 原生组件需在主进程调用
- 文件操作要考虑安全性，防止路径遍历攻击
- 大文件操作要设置大小限制，避免内存溢出
- 异步操作要正确处理错误，提供用户友好的错误信息
- 路径处理要使用 path 模块，确保跨平台兼容性
- 文件监控要正确管理资源，避免内存泄漏
- 使用服务类模式组织文件系统相关代码
- 实现统一的错误处理和性能优化策略
- 考虑文件类型验证和大小限制等安全措施
