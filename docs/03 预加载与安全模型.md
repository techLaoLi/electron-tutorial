## 03 预加载与安全模型

- 目标：安全地在渲染进程中使用被许可的 Node 能力。

### 为什么需要预加载（preload）
- 在启用 `contextIsolation: true` 与 `nodeIntegration: false` 的前提下，渲染端默认无法直接使用 Node API，需通过预加载桥接受控能力。

### 预加载脚本职责
- 使用 `contextBridge.exposeInMainWorld` 暴露白名单 API
- 通过 `ipcRenderer` 与主进程通信

### 示例（TypeScript）
预加载脚本代码：
```ts
import { contextBridge, ipcRenderer } from 'electron'

contextBridge.exposeInMainWorld('api', {
  getAppVersion: () => ipcRenderer.invoke('app:get-version'),
  readTextFile: (filePath: string) => ipcRenderer.invoke('fs:read-text', filePath)
})
```

主进程处理事件代码：
```js
import { ipcMain, app } from 'electron'
import fs from 'node:fs/promises'

// 处理获取应用版本号请求
ipcMain.handle('app:get-version', () => {
  return app.getVersion()
})

// 处理读取文本文件请求
ipcMain.handle('fs:read-text', async (_event, filePath) => {
  // 注意：在实际应用中应该添加文件路径验证逻辑
  const content = await fs.readFile(filePath, 'utf8')
  return content
})
```

渲染端使用：
```js
window.api.getAppVersion().then(v => console.log(v))
```

### 安全基线
- 关闭 `nodeIntegration`
- 打开 `contextIsolation`
- 仅通过预加载暴露最小必要 API
- 校验 IPC 入参，永远不要执行拼接命令

### 本章要点
- 预加载是安全边界，保证可控授权与最小暴露
